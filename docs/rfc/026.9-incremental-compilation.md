# RFC-026.9: Incremental Compilation

**Status**: Draft  
**Priority**: Medium (Live Coding Enabler)  
**Prerequisites**: RFC-026 Phase 3 (Streaming Coalesce) ✅  
**Estimated Effort**: 3-5 days  
**Breaking Change**: None (additive API)

---

## 1. Problem Statement

Full recompilation is wasteful when only a subset of operations change. For a 1000-operation clip where the user changes one note's pitch, we currently:

- Re-expand all loops
- Recompute all beat timings
- Re-coalesce all ties
- Re-emit all events

**Target Use Cases:**

| Use Case | Requirement |
|----------|-------------|
| Live coding | Instant feedback on single-note edits |
| Editor preview | Real-time compilation as user types |
| Hot reload | Recompile only changed clips |

---

## 2. Section Model

### 2.1 Definition

A **Section** is a contiguous range of top-level `ClipOperation[]` items in a `ClipNode`. Sections are the unit of cache invalidation.

```typescript
// src/compiler/incremental/types.ts

interface Section {
  /** Index range in ClipNode.operations[] */
  startIndex: number
  endIndex: number
  
  /** Content hash of operations in this section */
  hash: string
  
  /** Beat range after timing phase */
  startBeat: number
  endBeat: number
}
```

### 2.2 Section Boundaries

Sections are delimited by **structural operations** that affect downstream state:

| Operation | Creates Boundary | Reason |
|-----------|------------------|--------|
| `TempoOp` | Yes | Changes BPM for all subsequent |
| `TimeSignatureOp` | Yes | Changes measure calculation |
| `LoopOp` | Yes | Expansion count affects beat timing |
| `StackOp` | Yes | Branch timing is complex |
| `ScopeOp` | Yes | Isolation affects state propagation |
| `NoteOp` | No | Leaf operation |
| `RestOp` | No | Leaf operation |
| `ControlOp` | No | No timing effect |

### 2.3 Section Detection Algorithm

```typescript
// src/compiler/incremental/sections.ts

function detectSections(clip: ClipNode): Section[] {
  const sections: Section[] = []
  let currentStart = 0
  
  for (let i = 0; i < clip.operations.length; i++) {
    const op = clip.operations[i]
    
    if (isSectionBoundary(op) && i > currentStart) {
      sections.push({
        startIndex: currentStart,
        endIndex: i - 1,
        hash: hashOperations(clip.operations.slice(currentStart, i)),
        startBeat: 0,  // Computed after timing
        endBeat: 0
      })
      currentStart = i
    }
  }
  
  // Final section
  if (currentStart < clip.operations.length) {
    sections.push({
      startIndex: currentStart,
      endIndex: clip.operations.length - 1,
      hash: hashOperations(clip.operations.slice(currentStart)),
      startBeat: 0,
      endBeat: 0
    })
  }
  
  return sections
}

function isSectionBoundary(op: ClipOperation): boolean {
  return op.kind === 'tempo' 
      || op.kind === 'time_signature'
      || op.kind === 'loop'
      || op.kind === 'stack'
      || op.kind === 'scope'
}
```

---

## 3. Hash Algorithm

### 3.1 Operation Hashing

Hash captures all properties that affect output:

```typescript
// src/compiler/incremental/hash.ts

import { createHash } from 'crypto'

function hashOperation(op: ClipOperation): string {
  const serialized = stableSerialize(op)
  return createHash('sha256').update(serialized).digest('hex').slice(0, 16)
}

function hashOperations(ops: ClipOperation[]): string {
  const combined = ops.map(hashOperation).join(':')
  return createHash('sha256').update(combined).digest('hex').slice(0, 16)
}

function stableSerialize(obj: any): string {
  if (obj === null || obj === undefined) return 'null'
  if (typeof obj !== 'object') return JSON.stringify(obj)
  
  // Skip _source (debug metadata only)
  const keys = Object.keys(obj)
    .filter(k => k !== '_source')
    .sort()
  
  const pairs = keys.map(k => `${k}:${stableSerialize(obj[k])}`)
  return `{${pairs.join(',')}}`
}
```

### 3.2 Hash Inclusions/Exclusions

| Property | Included | Reason |
|----------|----------|--------|
| `_source` | No | Debug metadata only |
| `humanize.seed` | Yes | Affects output determinism |
| `expressionId` | Yes | Affects tie chain resolution |
| Nested `ClipOp.clip` | Yes | Recurse into child operations |

---

## 4. State Snapshot

### 4.1 Projection State

After processing section N, capture state needed to resume at section N+1:

```typescript
// src/compiler/incremental/types.ts

interface ProjectionSnapshot {
  /** Beat position after section */
  beat: number
  
  /** Measure number after section */
  measure: number
  
  /** Beat within current measure */
  beatInMeasure: number
  
  /** Active tempo (BPM) */
  bpm: number
  
  /** Active time signature */
  timeSignature: TimeSignatureString
  
  /** Active transposition (semitones) */
  transposition: number
  
  /** Active dynamics velocity multiplier */
  velocityMultiplier: number
  
  /** Active ties: expressionId:pitch → TieState */
  activeTies: Map<string, TieState>
}

interface TieState {
  startBeat: number
  startOp: TimedPipelineOp
  accumulatedDuration: number
}
```

### 4.2 Snapshot Capture

```typescript
function captureSnapshot(
  sequence: TimedSequence,
  sectionEndIndex: number,
  context: { bpm: number; timeSignature: TimeSignatureString }
): ProjectionSnapshot {
  const lastOp = sequence.operations[sectionEndIndex]
  
  return {
    beat: lastOp.beatStart + lastOp.beatDuration,
    measure: lastOp.measure,
    beatInMeasure: computeBeatInMeasure(lastOp, context.timeSignature),
    bpm: getCurrentBpm(sequence, sectionEndIndex),
    timeSignature: getCurrentTimeSig(sequence, sectionEndIndex),
    transposition: getCurrentTransposition(sequence, sectionEndIndex),
    velocityMultiplier: getCurrentVelocity(sequence, sectionEndIndex),
    activeTies: getActiveTies(sequence, sectionEndIndex)
  }
}
```

---

## 5. Cache Structure

```typescript
// src/compiler/incremental/cache.ts

interface CompilationCache {
  /** Clip identity (name) */
  clipId: string
  
  /** Cached sections with compiled output */
  sections: CachedSection[]
  
  /** Last full compilation for fallback */
  lastFullResult?: CompiledClip
}

interface CachedSection {
  /** Content hash of source operations */
  hash: string
  
  /** Index range in source ClipNode.operations[] */
  startIndex: number
  endIndex: number
  
  /** Projection state at section START */
  entryState: ProjectionSnapshot
  
  /** Projection state at section END */
  exitState: ProjectionSnapshot
  
  /** Compiled events for this section */
  events: CompiledEvent[]
}
```

---

## 6. Invalidation Rules

### 6.1 Change Detection

```typescript
function findInvalidatedSections(
  oldSections: Section[],
  newSections: Section[]
): { firstChanged: number; cascadeAll: boolean } {
  
  for (let i = 0; i < Math.max(oldSections.length, newSections.length); i++) {
    const oldS = oldSections[i]
    const newS = newSections[i]
    
    // Section added/removed → cascade all
    if (!oldS || !newS) {
      return { firstChanged: i, cascadeAll: true }
    }
    
    // Hash changed → check change type
    if (oldS.hash !== newS.hash) {
      const changeType = detectChangeType(oldS, newS)
      
      // Duration-affecting change → cascade
      if (changeType.affectsDuration) {
        return { firstChanged: i, cascadeAll: true }
      }
      
      // Non-duration change → only this section
      return { firstChanged: i, cascadeAll: false }
    }
  }
  
  return { firstChanged: -1, cascadeAll: false }  // No changes
}
```

### 6.2 Cascade Rules

| Change Type | Invalidates | Reason |
|-------------|-------------|--------|
| Note pitch | This section only | Beat timing unchanged |
| Note velocity | This section only | Beat timing unchanged |
| Note duration | This + all subsequent | Beat positions shift |
| Add/remove operation | This + all subsequent | Beat positions shift |
| Tempo change | This + all subsequent | Time calculations change |
| Time signature | This + all subsequent | Measure boundaries shift |
| Loop count | This + all subsequent | Expansion count differs |

---

## 7. Incremental Compilation Algorithm

```typescript
// src/compiler/incremental/compile.ts

function incrementalCompile(
  clip: ClipNode,
  cache: CompilationCache | null,
  options: PipelineOptions
): { result: CompiledClip; cache: CompilationCache } {
  
  // 1. Detect sections
  const newSections = detectSections(clip)
  
  // 2. No cache → full compile
  if (!cache) {
    const result = compileClip(clip, options)
    const newCache = buildCache(clip, newSections, result)
    return { result, cache: newCache }
  }
  
  // 3. Find first changed section
  const { firstChanged, cascadeAll } = findInvalidatedSections(
    cache.sections.map(s => ({ 
      startIndex: s.startIndex, 
      endIndex: s.endIndex, 
      hash: s.hash,
      startBeat: 0,
      endBeat: 0
    })),
    newSections
  )
  
  // 4. No changes → return cached
  if (firstChanged === -1) {
    return { result: cache.lastFullResult!, cache }
  }
  
  // 5. Get entry state
  const entryState = firstChanged > 0 
    ? cache.sections[firstChanged - 1].exitState
    : initialProjectionState(options)
  
  // 6. Determine recompilation scope
  if (cascadeAll || firstChanged === 0) {
    // Recompile from firstChanged to end
    const partialClip = sliceClip(clip, newSections[firstChanged].startIndex)
    const partialResult = compileClipFromState(partialClip, entryState, options)
    
    // Merge with cached prefix
    const mergedEvents = [
      ...cache.sections.slice(0, firstChanged).flatMap(s => s.events),
      ...partialResult.events
    ]
    
    const result = finalizeResult(mergedEvents, options)
    const newCache = updateCache(cache, firstChanged, newSections, partialResult)
    
    return { result, cache: newCache }
  }
  
  // 7. Non-cascading → recompile only affected section
  const affectedSection = newSections[firstChanged]
  const sectionOps = clip.operations.slice(
    affectedSection.startIndex,
    affectedSection.endIndex + 1
  )
  const sectionResult = compileSectionFromState(sectionOps, entryState, options)
  
  // Splice into cached events
  const mergedEvents = [
    ...cache.sections.slice(0, firstChanged).flatMap(s => s.events),
    ...sectionResult.events,
    ...cache.sections.slice(firstChanged + 1).flatMap(s => s.events)
  ]
  
  const result = finalizeResult(mergedEvents, options)
  const newCache = spliceCache(cache, firstChanged, sectionResult)
  
  return { result, cache: newCache }
}
```

---

## 8. API Surface

### 8.1 PipelineOptions Extension

```typescript
// Addition to src/compiler/pipeline/index.ts

interface PipelineOptions {
  // ... existing options ...
  
  /**
   * Enable incremental compilation.
   * Pass cache between compilations for reuse.
   * @experimental
   */
  incremental?: boolean
}
```

### 8.2 Public API

```typescript
// src/compiler/incremental/index.ts

export { incrementalCompile } from './compile'
export { createCache, type CompilationCache } from './cache'
export { detectSections, type Section } from './sections'
export { hashOperations } from './hash'
```

### 8.3 Usage Example

```typescript
import { incrementalCompile, createCache } from 'symphonyscript'

// First compilation
const clip1 = Clip.melody('Song').note('C4').note('D4').note('E4').build()
const { result: r1, cache: c1 } = incrementalCompile(clip1, null, { bpm: 120 })

// User changes D4 → F4 (pitch only, no cascade)
const clip2 = Clip.melody('Song').note('C4').note('F4').note('E4').build()
const { result: r2, cache: c2 } = incrementalCompile(clip2, c1, { bpm: 120 })
// Only section containing the changed note recompiled

// User changes note duration (cascade required)
const clip3 = Clip.melody('Song').note('C4', '2n').note('F4').note('E4').build()
const { result: r3, cache: c3 } = incrementalCompile(clip3, c2, { bpm: 120 })
// All sections from change point recompiled
```

---

## 9. Limitations

| Limitation | Impact | Mitigation |
|------------|--------|------------|
| Tie chains crossing sections | Requires state tracking | `activeTies` in snapshot |
| Duration changes cascade | Limited incremental benefit | Accept full recompile |
| Nested `ClipOp` changes | Invalidates containing section | Hash recurses into children |
| `BlockOp` references | Opaque compiled content | Hash `block.id` only |
| Random/humanize | Seed affects output | Include seed in hash |

---

## 10. Files to Add/Modify

| Action | Path | Description |
|--------|------|-------------|
| ADD | `src/compiler/incremental/types.ts` | Section, Snapshot, Cache interfaces |
| ADD | `src/compiler/incremental/sections.ts` | `detectSections`, `isSectionBoundary` |
| ADD | `src/compiler/incremental/hash.ts` | `stableSerialize`, `hashOperation`, `hashOperations` |
| ADD | `src/compiler/incremental/cache.ts` | `createCache`, `buildCache`, `updateCache`, `spliceCache` |
| ADD | `src/compiler/incremental/compile.ts` | `incrementalCompile`, `findInvalidatedSections` |
| ADD | `src/compiler/incremental/index.ts` | Public exports |
| MODIFY | `src/compiler/pipeline/index.ts` | Add `incremental` flag to `PipelineOptions` |
| ADD | `src/__tests__/incremental.test.ts` | Cache hit, partial recompile, cascade tests |

---

## 11. Testing Strategy

```typescript
describe('Incremental Compilation', () => {
  it('returns cached result for identical clip', () => {
    const clip = Clip.melody('Test').note('C4').build()
    const { cache } = incrementalCompile(clip, null, opts)
    const { result } = incrementalCompile(clip, cache, opts)
    // Verify cache hit, no recompilation
  })
  
  it('partial recompile for pitch change (no cascade)', () => {
    const clip1 = Clip.melody('Test').note('C4').note('D4').build()
    const { cache } = incrementalCompile(clip1, null, opts)
    
    const clip2 = Clip.melody('Test').note('C4').note('E4').build()
    const { result } = incrementalCompile(clip2, cache, opts)
    // Only second section recompiled
  })
  
  it('cascade recompile for duration change', () => {
    const clip1 = Clip.melody('Test').note('C4', '4n').note('D4').build()
    const { cache } = incrementalCompile(clip1, null, opts)
    
    const clip2 = Clip.melody('Test').note('C4', '2n').note('D4').build()
    const { result } = incrementalCompile(clip2, cache, opts)
    // All sections from C4 onward recompiled
  })
  
  it('preserves output correctness vs full compile', () => {
    const clip = createComplexClip()
    const fullResult = compileClip(clip, opts)
    const { result: incResult } = incrementalCompile(clip, null, opts)
    expect(incResult.events).toEqual(fullResult.events)
  })
  
  it('handles tie chains crossing section boundaries', () => {
    const clip = Clip.melody('Test')
      .note('C4', '2n').tie('start')
      .tempo(100)  // Section boundary
      .note('C4', '2n').tie('end')
      .build()
    // Verify tie resolves correctly across sections
  })
})
```

---

## 12. Performance Expectations

| Scenario | Full Compile | Incremental |
|----------|--------------|-------------|
| No change | 100% work | ~1% (hash compare only) |
| Pitch/velocity change | 100% work | ~10-20% (one section) |
| Duration change | 100% work | ~50-100% (cascade) |
| Add/remove operation | 100% work | ~50-100% (cascade) |

**Primary benefit**: Pitch and velocity edits during live coding see 5-10x speedup.

---

## 13. Implementation Order

1. **types.ts** — Define all interfaces
2. **hash.ts** — Stable serialization and hashing
3. **sections.ts** — Section detection algorithm
4. **cache.ts** — Cache creation and management
5. **compile.ts** — Incremental algorithm
6. **index.ts** — Public exports
7. **tests** — Verify correctness
8. **integration** — Add to `PipelineOptions`

---

## 14. Open Questions

1. **Section granularity**: Should consecutive leaf operations (notes, rests) be grouped into larger sections for fewer cache entries?
2. **Cache persistence**: Should cache survive across sessions (file-based) or be memory-only?
3. **Memory limits**: Should cache evict old sections when size exceeds threshold?

---

## 15. Approval

- [ ] Approved for implementation
- [ ] Requires revision (see comments)
