# RFC-048: Pluggable ID Resolution Strategy

| Metadata | Value |
| --- | --- |
| **Title** | **Pluggable ID Resolution Strategy** |
| **Status** | **PLANNING** |
| **Target** | `packages/kernel/` |
| **Goals** | Strategy Pattern, Zero-Allocation, Configurable Performance |
| **Depends On** | RFC-047 (Kernel Engine) |

## 1. Executive Summary

The current Kernel uses a **Hash Table (ID Table)** for sourceId â†’ NodePtr lookups. While functional (approx 83 microseconds per insert), this approach has inherent linear probing overhead under load.

RFC-048 proposes a **Pluggable Strategy Pattern** that allows users to choose between two distinct ID management lifecycles:

1. **ID Table (Hash Map)**: Supports Bring-Your-Own-ID (BYOID). Slower, but allows persistence stability.
2. **Generational Handles (Arena)**: System-assigned IDs. O(1) array access, approx 0.5 microseconds insert/lookup (160x faster).

Both strategies share a common interface, but they impose different constraints on the client regarding ID ownership. The choice is made at kernel initialization and cannot be changed at runtime.

## 2. The Performance Problem

### Current State: ID Table Only

Operations involve hashing and probing (1-5 iterations). Even with quadratic probing and 2x capacity, hash collisions cause multiple `Atomics.load()` calls per operation. Insert/Lookup times hover around 80 microseconds.

### Proposed: Generational Handles

Operations involve direct array slot assignment. Insert/Lookup times drop to approx 0.5 microseconds.
**Key Insight**: No hashing, no probing. Direct array indexing using opaque handles.

## 3. Architecture

### 3.1. The Strategy Interface

The interface must accommodate both "User-Owned" and "System-Owned" ID patterns.

```typescript
interface IdResolver {
  /**
   * Register a node pointer.
   * explicitId: Required for Table strategy (the User's ID). Ignored/Unused by Generational strategy.
   * Returns: The handle to be used for future lookups.
   * - For Table: Returns explicitId.
   * - For Gen: Returns a new system-generated handle.
   */
  register(ptr: NodePtr, explicitId?: number): number;

  /**
   * Lookup a NodePtr by handle.
   * Returns NULL_PTR if handle is invalid/stale.
   */
  lookup(handle: number): NodePtr;

  /**
   * Remove a handle.
   * Returns true if successful.
   */
  remove(handle: number): boolean;

  /**
   * Clear all entries.
   */
  clear(): void;
}

```

### 3.2. Concrete Implementations

#### A. ID Table (Hash Map)

* **Behavior**: Associative Map.
* **Contract**: Client owns the ID.
* **Implementation**: Existing quadratic probing logic.
* **Pros**: Persistence is easy (IDs don't change between reloads).

#### B. Generational Handles (Arena)

* **Behavior**: Allocator / Vector.
* **Contract**: System owns the ID. Client must map UI IDs to these handles.
* **Implementation Details**:
* Uses a flat `Int32Array` for slots: `[generation, ptr, generation, ptr, ...]`.
* Uses a **Lock-Free Index Stack** for free slots (reusing the logic from `symphonyscript/packages/kernel/src/free-list.ts`) to ensure thread safety.
* **Handle Format**: `(generation << slotBits) | slotIndex`.



**Concurrency Fix**:
The previous proposal used a simple array push for the free list, which is not thread-safe in `SharedArrayBuffer` environments. The revised implementation will use the tagged-pointer CAS pattern defined in `free-list.ts` to manage the stack of free indices without locking.

### 3.3. Kernel Integration

```typescript
class SiliconSynapse {
  private resolver: IdResolver;

  constructor(sab: SharedArrayBuffer, options: KernelOptions) {
    this.resolver = options.idStrategy === 'generational-handles'
      ? new GenerationalResolver(options)
      : new IdTableResolver(options);
  }

  insertHead(sourceId, ...): NodePtr {
    const ptr = this.allocNode();
    // CRITICAL: We return the handle from the resolver.
    // If using Generational, 'sourceId' is ignored, and the client receives a new handle.
    const handle = this.resolver.register(ptr, sourceId); 
    return ptr;
  }
}

```

## 4. Trade-offs

| Property | ID Table | Generational Handles |
| --- | --- | --- |
| **ID Ownership** | **Client Owned** (BYOID) | **Kernel Owned** (Opaque Handle) |
| **Persistence** | Stable. IDs persist across save/load. | Ephemeral. IDs change on every run. Client MUST remap IDs on load. |
| **Speed** | Slower (80 microseconds) | Blazing Fast (0.5 microseconds) |
| **Memory** | 2x overhead for load factor | Dense packing (no load factor overhead) |

## 5. Implementation Plan

### Phase 1: Interface Definition

* Define `IdResolver` interface.
* Refactor existing ID table logic into `IdTableResolver`.

### Phase 2: Generational Handles

* Implement `GenerationalResolver` using the FreeList pattern (from `packages/kernel/src/free-list.ts`) for the free slot stack.
* Implement generation checking for stale handle detection.

### Phase 3: Client Handling

* Update the Typescript SDK (`Synaptic`) to handle the mapping layer if Generational Strategy is selected.

## 6. Verification Plan

### Unit Tests

* Verify `IdTableResolver` preserves provided IDs.
* Verify `GenerationalResolver` creates unique handles and detects stale access (ABA protection).
* **Concurrency test**: Multiple threads allocating handles simultaneously using the lock-free stack.

### Constraints

* **Zero-Allocation**: Both strategies must be zero-allocation after init.
* **Thread-Safety**: All operations must use `Atomics` (verified by FreeList pattern).

## 7. Architect's Note

This RFC introduces a bifurcation in complexity. The "ID Table" is the "Easy Mode" for clients (IDs just work). "Generational Handles" is the "Performance Mode" but requires the client to maintain a mapping of `User_ID -> Kernel_Handle`. We provide both to support both rapid prototyping and high-frequency trading levels of audio performance.

**Ratification Status:** PENDING REVIEW
