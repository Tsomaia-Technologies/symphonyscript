# RFC-048.5: Main-Thread ID Resolution

| Metadata | Value |
| --- | --- |
| **Title** | **Main-Thread ID Resolution** |
| **Status** | **DRAFT** |
| **Supersedes** | RFC-048.1, RFC-048.2 |
| **Target** | `packages/kernel/` |
| **Goals** | 80x Faster Lookups, Minimal Change, Preserve Declarative Model |

---

## 1. Executive Summary

The current ID Table lives in SharedArrayBuffer (SAB) and uses Atomics + quadratic probing, resulting in ~80µs per lookup. However, **ID lookups only occur on the main thread** — the AudioWorklet never looks up by sourceId.

This RFC proposes moving the ID Table from SAB to a **simple JS Map on main thread**, achieving ~80x speedup with minimal architectural change.

| Approach | Lookup Speed | Change Required |
|----------|--------------|-----------------|
| SAB ID Table (current) | ~80µs | - |
| **JS Map (proposed)** | **~1µs** | Move map to Bridge |
| Generational Handles | ~0.5µs | Complex, breaks declarative model |

---

## 2. The Problem

### Why Is the SAB ID Table Slow?

```typescript
// Current: SAB-based ID Table
idTableLookup(sourceId):
  1. hash = knuthHash(sourceId)           // ~5ns
  2. slot = hash & (capacity - 1)          // ~1ns
  3. loop: quadratic probe until found     // ~70µs (Atomics overhead!)
     - Atomics.load(tid)
     - Atomics.load(ptr)
     - probe to next slot
  
  Total: ~80µs
```

The bottleneck is **Atomics on SAB**. Each `Atomics.load()` has memory barrier overhead that compounds during probing.

### Why Is It In SAB?

The ID Table was designed for thread-safety — assuming Worker threads might need to lookup by sourceId.

**But they don't.**

| Thread | ID Lookup? | What It Does |
|--------|------------|--------------|
| Main thread | ✅ Yes | `insertAsync`, `patchNote`, `deleteNote` |
| AudioWorklet | ❌ No | Traverses node chain via NodePtr directly |

Thread-safety for ID lookups is **wasted overhead**.

---

## 3. The Solution

Move the ID mapping to a simple **JS Map on main thread**:

```typescript
class SiliconBridge {
  private idMap: Map<number, NodePtr> = new Map();
  
  insertAsync(sourceId: number, ...): NodePtr {
    const ptr = this.kernel.allocNode();
    this.writeNodeData(ptr, ...);
    this.kernel.linkNode(ptr);
    this.idMap.set(sourceId, ptr);  // O(1)
    return ptr;
  }
  
  lookupBySourceId(sourceId: number): NodePtr | null {
    return this.idMap.get(sourceId) ?? null;  // ~1µs
  }
  
  deleteBySourceId(sourceId: number): boolean {
    const ptr = this.idMap.get(sourceId);
    if (!ptr) return false;
    this.kernel.deleteNode(ptr);
    this.idMap.delete(sourceId);
    return true;
  }
}
```

### Performance Comparison

| Operation | SAB ID Table | JS Map |
|-----------|--------------|--------|
| Single lookup | ~80µs | ~1µs |
| 5000 note bulk | ~400ms | ~5ms |
| **Speedup** | - | **80x** |

---

## 4. Why Not Generational Handles?

RFC-048.2 explored Generational Handles as an alternative. The analysis concluded:

### The Declarative Model Constraint

SymphonyScript uses a declarative model:

```typescript
Clip.melody()
    .note('C4', '4n')
    .note('G4', '4n')
    .note('F4', '4n')
```

Live-editing requires:
```
Source location → Identity → Find existing node → Patch
```

**Generational Handles break this** because:
1. Handles are kernel-generated, not source-derived
2. Re-evaluation produces new handles
3. No stable identity between edits

**ID Table (or JS Map) preserves this** because:
- `sourceId = hash(file, line)` is stable
- Same source line always maps to same node

### Generational Handles Would Require

Either:
1. Storing handles per-note (allocation — rejected)
2. A `sourceId → handle` mapping (another hash table — no net gain)

### Conclusion

Generational Handles add complexity without benefit for the declarative model.

---

## 5. What Stays in SAB?

| Component | Location | Reason |
|-----------|----------|--------|
| Node heap | SAB | AudioWorklet reads nodes |
| Node chain (HEAD_PTR, NEXT_PTR) | SAB | AudioWorklet traverses chain |
| Free list | SAB | Multi-zone allocation |
| Synapse table | SAB | AudioWorklet reads synapses |
| **ID Map** | **JS heap** | Main-thread only |
| Symbol table | JS heap (optional) | Debugging/source maps |

The SAB remains the source of truth for **audio-thread data**. The JS Map is for **main-thread lookups only**.

---

## 6. Implementation Plan

### Phase 1: Add JS Map to Bridge

```typescript
// packages/kernel/src/silicon-bridge.ts

class SiliconBridge {
  private idMap: Map<number, NodePtr> = new Map();
  
  // ... existing methods updated to use idMap
}
```

### Phase 2: Remove SAB ID Table Usage

- Remove `idTableInsert`, `idTableLookup`, `idTableRemove` calls from Bridge
- Keep SAB ID Table code (don't delete) for potential BYOID use cases

### Phase 3: Remove SAB ID Table Allocation (Optional)

- If BYOID isn't needed, remove ID Table region from SAB
- Saves memory: `2 × nodeCapacity × 8 bytes`

---

## 7. Verification Plan

### Unit Tests

```typescript
describe('JS Map ID Resolution', () => {
  it('lookupBySourceId returns correct NodePtr', () => { ... });
  it('deleteBySourceId removes mapping', () => { ... });
  it('handles 10,000 concurrent mappings', () => { ... });
});
```

### Benchmarks

```bash
# Compare lookup performance
npx vitest bench --test=id-resolution

# Expected:
# SAB ID Table:  ~80µs per lookup
# JS Map:        ~1µs per lookup
```

---

## 8. Trade-offs

| Property | SAB ID Table | JS Map |
|----------|--------------|--------|
| **Speed** | ~80µs | ~1µs |
| **Thread-safe** | Yes (not needed) | No (not needed) |
| **BYOID support** | Yes | Yes |
| **Memory** | SAB region | JS heap |
| **Complexity** | High (Atomics, probing) | Low (native Map) |

---

## 9. Migration Path

### For Existing Code

1. Bridge methods remain unchanged in signature
2. Internal implementation switches to JS Map
3. No breaking changes to SynapticClip, SynapticNode, or user code

### For Rust Rewrite

The Rust kernel can use `HashMap` on main thread with same semantics.
Generational Handles can be reconsidered if architecture changes.

---

## 10. Architect's Notes

### Why This Wasn't Done Initially

The original RFC-043/044 design assumed multi-threaded access patterns:
- Multiple Workers writing to the same SAB
- Potential for ID lookups from Worker context

In practice:
- Only one Bridge exists per SAB
- ID lookups are always main-thread operations
- The thread-safety was premature optimization

### On Generational Handles

Generational Handles are excellent for:
- Game engines (entity-component systems)
- Rust (idiomatic with slotmap/thunderdome)
- Systems where handles are passed around opaquely

They're **not** a good fit for:
- Declarative models where identity is source-derived
- Systems that need stable IDs across re-evaluation

SymphonyScript's declarative model makes source-derived IDs the correct choice.

---

**Ratification Status:** PENDING REVIEW
