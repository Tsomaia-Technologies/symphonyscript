# RFC-048.2: Pluggable ID Resolution Strategy (Revision 2)

| Metadata | Value |
| --- | --- |
| **Title** | **Pluggable ID Resolution Strategy** |
| **Status** | **DRAFT** |
| **Supersedes** | RFC-048.1 |
| **Target** | `packages/kernel/`, `packages/synaptic/` |
| **Goals** | Strategy Pattern, Zero-Allocation, O(1) Lookups, 20/12 Bit Handles |
| **Depends On** | RFC-047 (Kernel Engine) |

---

## 1. Executive Summary

The current kernel uses an **ID Table (Hash Map)** for `sourceId → NodePtr` lookups. While functional (~80µs per operation), this approach has inherent linear/quadratic probing overhead under load.

RFC-048.2 proposes a **Pluggable Strategy Pattern** that separates concerns:

1. **sourceId** (stable identity) — derived from source location `hash(file, line)`, managed by Bridge/Synaptic
2. **handle** (fast lookup key) — internal to kernel, enables O(1) array access

Two concrete strategies implement the `IdResolver` interface:

| Strategy | Lookup Speed | ID Ownership | Use Case |
|----------|--------------|--------------|----------|
| **ID Table** | ~80µs (hash + probe) | Client-owned (BYOID) | Persistence, DAW-style editing |
| **Generational Handles** | ~0.5µs (O(1) array) | Kernel-owned | Live performance, maximum speed |

The choice is made at kernel initialization via **dependency injection** (class instance, not string config).

---

## 2. The Two-Layer Identity Model

> [!IMPORTANT]
> This is the critical architectural insight missing from RFC-048.1.

### Layer 1: sourceId (Stable Identity)

The `sourceId` is derived from **source code location**:

```typescript
sourceId = hash(filePath, lineNumber)
// Example: hash("melody.ss", 42) → 0x1A2B3C4D
```

This is **stable across edits** — if you change the pitch on line 42, the sourceId remains the same. Only moving or deleting the line changes the sourceId.

**Owner**: Bridge / Synaptic layer (not the kernel).

### Layer 2: handle (Fast Lookup Key)

The `handle` is an **opaque 32-bit integer** used for O(1) lookups:

```
┌─────────────────────────────────────────┐
│  Generational Handle (32-bit)           │
├──────────────────┬──────────────────────┤
│  Generation (12) │  Slot Index (20)     │
│  bits 31-20      │  bits 19-0           │
└──────────────────┴──────────────────────┘
```

- **Slot Index** (20 bits): Array index, supports 1,048,576 concurrent notes
- **Generation** (12 bits): ABA protection, 4,096 reuse cycles per slot

**Owner**: Kernel's `IdResolver` implementation.

### The Complete Flow

```
User Code (.note("C4"))
      ↓
sourceId = hash(file, line)     ← Synaptic/Bridge computes
      ↓
handle = resolver.insert(ptr)   ← Kernel allocates slot
      ↓
Map<sourceId, handle>           ← Bridge maintains mapping
      ↓
On edit: sourceId → handle → O(1) lookup → patch
```

---

## 3. Why Generational Handles?

### The Problem with ID Tables

```typescript
// Current ID Table lookup
idTableLookup(sourceId):
  1. hash = knuthHash(sourceId)           // ~5ns
  2. slot = hash & (capacity - 1)         // ~1ns
  3. loop: probe until found or empty     // ~70µs worst case (collisions!)
     - Atomics.load(tid)
     - Atomics.load(ptr)
     - quadratic probe to next slot
  
  Total: ~80µs average under load
```

### The Generational Handle Advantage

```typescript
// Generational Handle lookup
lookup(handle):
  1. slot = handle & 0xFFFFF               // ~1ns (bitwise AND)
  2. gen = handle >>> 20                   // ~1ns (shift)
  3. if (generations[slot] !== gen)        // ~2ns (array access)
       return null  // Stale handle
  4. return ptrs[slot]                     // ~2ns (array access)
  
  Total: ~6ns (no loops, no probing!)
```

**Performance gain: 100-150x faster lookups.**

---

## 4. The Strategy Interface

```typescript
/**
 * IdResolver - Pluggable ID resolution strategy.
 * 
 * Implementations must be zero-allocation after initialization.
 * All methods must be thread-safe (use Atomics on SharedArrayBuffer).
 */
interface IdResolver {
  /**
   * Register a NodePtr and return a handle for future lookups.
   * 
   * @param ptr - NodePtr to register
   * @returns handle (32-bit integer) for future lookups
   * @throws never - returns NULL_HANDLE on allocation failure
   */
  insert(ptr: NodePtr): number;
  
  /**
   * Lookup a NodePtr by handle.
   * 
   * @param handle - Previously returned handle
   * @returns NodePtr if valid, NULL_PTR if stale/invalid
   */
  lookup(handle: number): NodePtr;
  
  /**
   * Remove a handle, freeing the slot for reuse.
   * Bumps generation counter to invalidate stale handles.
   * 
   * @param handle - Handle to remove
   * @returns true if removed, false if already stale
   */
  remove(handle: number): boolean;
  
  /**
   * Clear all entries (bulk reset).
   */
  clear(): void;
}
```

### Key Design Decisions

1. **No sourceId parameter** — The kernel doesn't know or care about sourceId. The Bridge maintains the `Map<sourceId, handle>` mapping.

2. **Returns handle, not void** — The caller receives the handle immediately and must store it (in Bridge's Map).

3. **NULL_PTR for stale handles** — Generation mismatch returns null, not an error. Caller decides how to handle.

---

## 5. Concrete Implementations

### 5.1 ID Table (Hash Map)

The existing implementation from RFC-047, wrapped to conform to `IdResolver`:

```typescript
class IdTableResolver implements IdResolver {
  // Uses existing idTableInsert/idTableLookup/idTableRemove
  // Hash + quadratic probing
  // Suitable for BYOID (bring-your-own-ID) scenarios
}
```

**Modification**: The current ID Table stores `sourceId → NodePtr`. To work with this interface, it would store `autoIncrementId → NodePtr`, where `autoIncrementId` is the "handle" returned by `insert()`.

### 5.2 Generational Handles (Arena)

```typescript
class GenerationalResolver implements IdResolver {
  private sab: Int32Array;
  private generations: Int32Array;  // Per-slot generation counter
  private ptrs: Int32Array;         // Per-slot NodePtr storage
  private freeStack: number;        // Head of free slot stack (lock-free)
  
  private readonly SLOT_BITS = 20;
  private readonly GEN_BITS = 12;
  private readonly SLOT_MASK = 0xFFFFF;    // Lower 20 bits
  private readonly GEN_SHIFT = 20;
  private readonly MAX_SLOTS = 1 << 20;    // 1,048,576
  private readonly MAX_GEN = 1 << 12;      // 4,096
  
  insert(ptr: NodePtr): number {
    const slot = this.allocSlot();  // Lock-free pop from free stack
    if (slot === NULL_SLOT) return NULL_HANDLE;
    
    const gen = Atomics.load(this.generations, slot);
    Atomics.store(this.ptrs, slot, ptr);
    
    return (gen << this.GEN_SHIFT) | slot;
  }
  
  lookup(handle: number): NodePtr {
    const slot = handle & this.SLOT_MASK;
    const gen = handle >>> this.GEN_SHIFT;
    
    const currentGen = Atomics.load(this.generations, slot);
    if (currentGen !== gen) return NULL_PTR;  // Stale handle
    
    return Atomics.load(this.ptrs, slot);
  }
  
  remove(handle: number): boolean {
    const slot = handle & this.SLOT_MASK;
    const gen = handle >>> this.GEN_SHIFT;
    
    const currentGen = Atomics.load(this.generations, slot);
    if (currentGen !== gen) return false;  // Already stale
    
    // Bump generation (invalidates all handles to this slot)
    Atomics.add(this.generations, slot, 1);
    
    // Return slot to free stack
    this.freeSlot(slot);
    
    return true;
  }
}
```

### 5.3 FreeList Reuse

> [!TIP]
> The existing `FreeList` from `packages/kernel/src/free-list.ts` provides the lock-free slot allocation pattern.

**Option A: Derive slot from NodePtr** (recommended)

Since slots map 1:1 with heap positions:

```typescript
slot = (NodePtr - HEAP_START_OFFSET) / NODE_SIZE_BYTES
```

This means:
- `FreeList.alloc()` → NodePtr → derive slot automatically
- No separate slot allocator needed
- GenerationalResolver just adds the `generations[]` array

**Option B: Separate slot allocator**

Reuse the FreeList's tagged-pointer CAS pattern for slot indices:

```typescript
// In SAB header:
// FREE_SLOT_HEAD (64-bit): (version << 32) | slot_index

// Slot allocation uses same CAS loop as FreeList
```

**Recommendation**: Option A is simpler and avoids duplication.

---

## 6. Kernel Integration

### 6.1 Strategy Injection (Not String Config!)

```typescript
// ❌ WRONG: String-based config (inflexible)
createKernel({ idStrategy: 'generational-handles' });

// ✅ RIGHT: Dependency injection (flexible, testable)
createKernel({
  idResolver: new GenerationalResolver({ 
    slotBits: 20, 
    genBits: 12 
  })
});

// ✅ ALSO RIGHT: Factory function
createKernel({
  idResolverFactory: (sab) => new GenerationalResolver(sab)
});
```

### 6.2 SiliconSynapse Changes

```typescript
class SiliconSynapse implements ISiliconLinker {
  private resolver: IdResolver;
  
  constructor(buffer: SharedArrayBuffer, options: KernelOptions) {
    // ... existing init ...
    this.resolver = options.idResolver ?? new IdTableResolver(this.sab);
  }
  
  // Expose resolver for Bridge to use
  getResolver(): IdResolver {
    return this.resolver;
  }
}
```

### 6.3 Bridge Changes

```typescript
class SiliconBridge {
  private sourceIdToHandle: Map<number, number> = new Map();
  private kernel: SiliconSynapse;
  
  addNote(sourceId: number, pitch: number, ...): number {
    const ptr = this.kernel.allocNode();
    this.writeNodeData(ptr, pitch, ...);
    
    const handle = this.kernel.getResolver().insert(ptr);
    this.sourceIdToHandle.set(sourceId, handle);
    
    return handle;
  }
  
  patchNote(sourceId: number, newPitch: number): boolean {
    const handle = this.sourceIdToHandle.get(sourceId);
    if (handle === undefined) return false;
    
    const ptr = this.kernel.getResolver().lookup(handle);
    if (ptr === NULL_PTR) {
      // Stale handle - remove from map
      this.sourceIdToHandle.delete(sourceId);
      return false;
    }
    
    this.kernel.patchPitch(ptr, newPitch);
    return true;
  }
  
  deleteNote(sourceId: number): boolean {
    const handle = this.sourceIdToHandle.get(sourceId);
    if (handle === undefined) return false;
    
    const success = this.kernel.getResolver().remove(handle);
    this.sourceIdToHandle.delete(sourceId);
    
    return success;
  }
}
```

### 6.4 SynapticClip / SynapticNode

**No changes required.** They work with opaque `noteRef` numbers (which are handles under the hood). The abstraction holds.

---

## 7. NODE.SOURCE_ID Field

The current node structure has a `SOURCE_ID` field. With this design:

| Strategy | NODE.SOURCE_ID Usage |
|----------|---------------------|
| ID Table | Stores the sourceId (for reverse lookup) |
| Generational | **Still stores sourceId** (for debugging/source maps) |

The sourceId is still written to the node for debugging and error messages (e.g., "Error at melody.ss:42"). The handle is for fast lookup, not for identifying where code came from.

---

## 8. Memory Layout

### Generational Resolver SAB Region

Allocate after existing tables (ID Table, Symbol Table, Synapse Table):

```
┌──────────────────────────────────────────────────────────────┐
│  HEADER (128 bytes)                                          │
├──────────────────────────────────────────────────────────────┤
│  NODE HEAP (nodeCapacity × 32 bytes)                         │
├──────────────────────────────────────────────────────────────┤
│  ID TABLE (2 × nodeCapacity × 8 bytes) - if used            │
├──────────────────────────────────────────────────────────────┤
│  SYMBOL TABLE (nodeCapacity × 8 bytes) - if used            │
├──────────────────────────────────────────────────────────────┤
│  SYNAPSE TABLE (synapseCapacity × 12 bytes)                 │
├──────────────────────────────────────────────────────────────┤
│  GENERATIONAL RESOLVER REGION (if strategy selected):       │
│    - generations[]: Int32Array[maxSlots]  (4 × maxSlots)    │
│    - ptrs[]: Int32Array[maxSlots]         (4 × maxSlots)    │
│    - FREE_SLOT_HEAD (8 bytes, 64-bit tagged pointer)        │
│  Total: ~8MB for 1M slots                                    │
└──────────────────────────────────────────────────────────────┘
```

---

## 9. Trade-offs Summary

| Property | ID Table | Generational Handles |
|----------|----------|---------------------|
| **Lookup Speed** | ~80µs (hash + probe) | ~0.5µs (O(1) array) |
| **ID Ownership** | Client-owned (BYOID) | Kernel-owned (opaque) |
| **Persistence** | Stable IDs across save/load | Handles change on reload |
| **Memory** | 2× capacity for load factor | Dense packing |
| **Stale Detection** | N/A (IDs are stable) | Generation counter (ABA-safe) |
| **Complexity** | Simple hash table | Requires generation tracking |

---

## 10. Implementation Plan

### Phase 1: Interface Definition
- [ ] Define `IdResolver` interface in `packages/kernel/src/types.ts`
- [ ] Add `idResolver` option to `KernelOptions`
- [ ] Wrap existing ID Table logic into `IdTableResolver`

### Phase 2: Generational Handles
- [ ] Implement `GenerationalResolver` class
- [ ] Add SAB region calculation for generations/ptrs arrays
- [ ] Reuse FreeList pattern for slot allocation (Option A: derive from NodePtr)
- [ ] Implement generation checking and bumping

### Phase 3: Bridge Integration
- [ ] Add `sourceIdToHandle: Map<number, number>` to Bridge
- [ ] Update `addNote`, `patchNote`, `deleteNote` to use resolver
- [ ] Ensure SynapticClip/SynapticNode remain unchanged

### Phase 4: Testing
- [ ] Unit tests for both resolvers
- [ ] Concurrency tests (multiple workers allocating simultaneously)
- [ ] Stale handle detection tests (ABA scenario)
- [ ] Benchmark: ID Table vs Generational Handles

---

## 11. Verification Plan

### Unit Tests

```typescript
describe('GenerationalResolver', () => {
  it('returns unique handles for each insert', () => { ... });
  it('lookup returns correct NodePtr', () => { ... });
  it('detects stale handles after remove', () => { ... });
  it('reuses slots after remove', () => { ... });
  it('generation wraps correctly at MAX_GEN', () => { ... });
});

describe('Concurrency', () => {
  it('handles concurrent inserts without corruption', () => { ... });
  it('handles concurrent insert+remove without ABA', () => { ... });
});
```

### Benchmarks

```bash
# Compare strategies
npx vitest bench --strategy=id-table
npx vitest bench --strategy=generational-handles

# Expected results:
# ID Table:          ~80µs per lookup
# Generational:      ~0.5µs per lookup (160x faster)
```

---

## 12. Migration Path

### For Existing Code

1. **Default remains ID Table** — No breaking changes for existing users
2. **Opt-in to Generational Handles** — Pass resolver in options
3. **Persistence caveat** — If serializing compositions, store sourceId (stable), not handle (ephemeral)

### For Rust Rewrite

Generational handles are idiomatic in Rust. Use crates like `slotmap` or `thunderdome` for battle-tested implementations.

---

## 13. Architect's Notes

### Why Two Layers?

The separation of `sourceId` (stable identity) from `handle` (fast lookup) is critical:

- **sourceId** enables live-editing: "Line 42 changed" → same sourceId → find handle → patch
- **handle** enables O(1) lookups: No hashing, no probing, just array access

Conflating these (as RFC-048.1 did) leads to confusion about who owns what.

### Why Not Always Generational?

ID Table is simpler for:
- External tools that need stable IDs (DAW integration)
- Debugging (IDs are human-readable)
- Cases where persistence matters (scene/project files)

Generational Handles are better for:
- Live performance (maximum speed)
- Large compositions (no hash collisions)
- Future Rust/WASM port (idiomatic)

Both are valid choices. The Strategy Pattern lets users choose.

---

**Ratification Status:** PENDING REVIEW

---

## Appendix A: Handle Bit Allocation Options

| Config | Slots | Generations | Notes |
|--------|-------|-------------|-------|
| 16/16 | 65,536 | 65,536 | Balanced, but slot limit may bite |
| **20/12** | 1,048,576 | 4,096 | **Recommended** — 1M notes, plenty of reuses |
| 24/8 | 16,777,216 | 256 | Overkill slots, weak gen protection |

**Decision**: 20/12 split. 1 million concurrent notes is beyond any musical need. 4,096 reuse cycles per slot is sufficient.

---

## Appendix B: FreeList Pattern Reference

The existing `FreeList` in `packages/kernel/src/free-list.ts` uses:

```typescript
// 64-bit tagged pointer: (version << 32) | ptr
const head = Atomics.load(sab64, FREE_LIST_HEAD);
const ptr = Number(head & 0xFFFFFFFFn);
const version = head >> 32n;

// CAS to pop
const newHead = (newVersion << 32n) | BigInt(next);
Atomics.compareExchange(sab64, FREE_LIST_HEAD, head, newHead);
```

This pattern is directly applicable to `GenerationalResolver.allocSlot()`:

```typescript
// 64-bit tagged slot head: (version << 32) | slot
const head = Atomics.load(sab64, FREE_SLOT_HEAD);
const slot = Number(head & 0xFFFFFFFFn);
// ... same CAS pattern
```
