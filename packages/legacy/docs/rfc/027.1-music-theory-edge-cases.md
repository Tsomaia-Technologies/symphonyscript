# RFC-027.1: Music Theory Edge Cases

**Status**: Draft  
**Priority**: Medium  
**Estimated Effort**: 2 days  
**Breaking Change**: None (additive tests + fixes)  
**Dependencies**: RFC-027 (complete)

---

## 1. Purpose

Harden the music theory implementation (RFC-027) by handling edge cases:

- Enharmonic note handling
- Double sharps/flats
- Chord inversions
- Secondary dominants
- Modal interchange
- Voice crossing prevention

---

## 2. Edge Cases

### 2.1 Enharmonic Notes

**Problem:** `F#4` and `Gb4` are the same pitch but different spellings. In G major (which has F#), what happens to `Gb4`?

**Current behavior:** Unknown — needs test

**Expected behavior:**

```typescript
// Option A: Preserve user's spelling (safer)
applyKeySignature("Gb4", { root: "G", mode: "major" }); // → 'Gb4'

// Option B: Normalize to key spelling (more correct)
applyKeySignature("Gb4", { root: "G", mode: "major" }); // → 'F#4'
```

**Recommendation:** Option A (preserve spelling). Changing `Gb` to `F#` could break user intent.

### 2.2 Double Sharps/Flats

**Problem:** Theoretical keys like G# major have F## (double sharp).

**Current behavior:** Unknown — likely doesn't handle

**Test:**

```typescript
applyKeySignature("F#4", { root: "G#", mode: "major" }); // Should be F##4 or error?
```

**Recommendation:**

- Support common keys only (C, G, D, A, E, B, F#, Cb, F, Bb, Eb, Ab, Db, Gb)
- Throw on theoretical keys (G#, D#, A#) OR map to enharmonic (G# → Ab)

### 2.3 Chord Inversions

**Problem:** `I/3` means C major in first inversion (E in bass).

**Current `parseRomanNumeral`:** Likely doesn't parse inversions.

**Proposed:**

```typescript
parseRomanNumeral("I/3", "major");
// → { degree: 1, quality: '', inversion: 1 }

parseRomanNumeral("V65", "major"); // Figured bass
// → { degree: 5, quality: '7', inversion: 1 }
```

### 2.4 Secondary Dominants

**Problem:** `V/V` means "the V of V" (D major in C major).

**Current behavior:** Likely throws or parses incorrectly.

**Proposed:**

```typescript
romanToChord("V/V", { root: "C", mode: "major" });
// → 'D' (D major, which is V of G, and G is V of C)

romanToChord("V7/ii", { root: "C", mode: "major" });
// → 'A7' (A7 → Dm)
```

### 2.5 Modal Interchange

**Problem:** `bVII` in C major borrows Bb from C minor.

**Current behavior:** Unknown.

**Proposed:**

```typescript
romanToChord("bVII", { root: "C", mode: "major" });
// → 'Bb' (borrowed from parallel minor)

romanToChord("bIII", { root: "C", mode: "major" });
// → 'Eb'
```

### 2.6 Voice Crossing Prevention

**Problem:** Voice leading might output:

```
Voice 1: C4 → B4  (up)
Voice 2: E4 → C4  (down, crosses voice 1)
```

**Expected:** Voices should not cross in standard 4-part writing.

**Test:**

```typescript
const voiced = voiceLeadChords(chords, { preventCrossing: true });
// Assert: voiced[n][v] <= voiced[n][v+1] for all n, v
```

---

## 3. Proposed Changes

### 3.1 Enharmonic Handling

```typescript
// keys.ts

/**
 * Check if note already has an accidental.
 * If so, preserve user's spelling.
 */
function hasExplicitAccidental(noteName: string): boolean {
  return noteName.includes("#") || noteName.includes("b");
}

export function applyKeySignature(
  noteName: string,
  keyContext: KeyContext | undefined,
  overrideAccidental?: Accidental
): string {
  // NEW: Preserve notes that already have accidentals
  if (hasExplicitAccidental(noteName) && !overrideAccidental) {
    return noteName;
  }
  // ... existing logic
}
```

### 3.2 Key Validation

```typescript
// keys.ts

const SUPPORTED_KEYS = new Set([
  // Major
  "C:major",
  "G:major",
  "D:major",
  "A:major",
  "E:major",
  "B:major",
  "F#:major",
  "Cb:major",
  "F:major",
  "Bb:major",
  "Eb:major",
  "Ab:major",
  "Db:major",
  "Gb:major",
  // Minor (relative)
  "A:minor",
  "E:minor",
  "B:minor",
  "F#:minor",
  "C#:minor",
  "G#:minor",
  "D#:minor",
  "A#:minor",
  "D:minor",
  "G:minor",
  "C:minor",
  "F:minor",
  "Bb:minor",
  "Eb:minor",
]);

export function isValidKey(root: string, mode: string): boolean {
  return SUPPORTED_KEYS.has(`${root}:${mode}`);
}
```

### 3.3 Inversion Parsing

```typescript
// progressions.ts

interface ParsedNumeral {
  degree: number;
  quality: string;
  inversion?: number;
  secondary?: number; // For V/V
}

export function parseRomanNumeral(
  numeral: string,
  mode: string
): ParsedNumeral {
  // Match: [b#]?[iIvV]+[quality]?[/inversion or /secondary]?
  const match = numeral.match(/^(b|#)?([ivIV]+)(.*?)(?:\/(\d|[ivIV]+))?$/);

  if (!match) throw new Error(`Invalid numeral: ${numeral}`);

  const [, accidental, roman, quality, slash] = match;

  // ... parse degree, quality

  // Parse slash notation
  if (slash) {
    if (/^\d$/.test(slash)) {
      // Inversion: I/3 → first inversion
      result.inversion = parseInt(slash) - 1;
    } else {
      // Secondary: V/V → secondary dominant
      result.secondary = romanToDegreee(slash);
    }
  }

  return result;
}
```

### 3.4 Modal Interchange

```typescript
// progressions.ts

const MODAL_INTERCHANGE: Record<string, number> = {
  bII: 1, // Neapolitan
  bIII: 3,
  bVI: 8,
  bVII: 10,
};

export function romanToChord(numeral: string, keyContext: KeyContext): string {
  const parsed = parseRomanNumeral(numeral, keyContext.mode);

  // Handle modal interchange (borrowed chords)
  if (parsed.accidental === "b" && MODAL_INTERCHANGE[numeral.toUpperCase()]) {
    // ... resolve from parallel minor
  }

  // ... existing logic
}
```

### 3.5 Voice Crossing Prevention

```typescript
// voiceleading.ts

interface VoiceLeadOptions {
  voices?: number;
  style?: VoiceLeadingStyle;
  preventCrossing?: boolean; // NEW
}

function sortVoices(notes: NoteName[]): NoteName[] {
  return [...notes].sort((a, b) => noteToMidi(a) - noteToMidi(b));
}

export function voiceLeadChords(
  chords: NoteName[][],
  options: VoiceLeadOptions = {}
): NoteName[][] {
  const { preventCrossing = true } = options;

  const result: NoteName[][] = [sortVoices(chords[0])];

  for (let i = 1; i < chords.length; i++) {
    let voiced = findMinimalMovement(result[i - 1], chords[i]);

    if (preventCrossing) {
      voiced = sortVoices(voiced);
    }

    result.push(voiced);
  }

  return result;
}
```

---

## 4. Files to Modify

| File                           | Changes                                            |
| ------------------------------ | -------------------------------------------------- |
| `src/theory/keys.ts`           | Enharmonic handling, key validation                |
| `src/theory/progressions.ts`   | Inversions, secondary dominants, modal interchange |
| `src/theory/voiceleading.ts`   | Voice crossing prevention                          |
| `src/__tests__/theory.test.ts` | Edge case tests                                    |

---

## 5. Testing Strategy

```typescript
describe("Edge Cases", () => {
  describe("Enharmonic notes", () => {
    it("preserves explicit accidentals", () => {
      expect(applyKeySignature("Gb4", { root: "G", mode: "major" })).toBe(
        "Gb4"
      );
      expect(applyKeySignature("F#4", { root: "C", mode: "major" })).toBe(
        "F#4"
      );
    });
  });

  describe("Inversions", () => {
    it("parses slash inversions", () => {
      const parsed = parseRomanNumeral("I/3", "major");
      expect(parsed.inversion).toBe(0); // First inversion = index 0
    });
  });

  describe("Secondary dominants", () => {
    it("parses V/V", () => {
      const chord = romanToChord("V/V", { root: "C", mode: "major" });
      expect(chord).toBe("D"); // D major
    });
  });

  describe("Modal interchange", () => {
    it("handles bVII", () => {
      const chord = romanToChord("bVII", { root: "C", mode: "major" });
      expect(chord).toBe("Bb");
    });
  });

  describe("Voice crossing", () => {
    it("prevents voice crossing by default", () => {
      const chords = [
        ["C4", "E4", "G4", "C5"],
        ["D4", "F4", "A4", "D5"],
      ];
      const voiced = voiceLeadChords(chords as any);

      for (const chord of voiced) {
        for (let i = 0; i < chord.length - 1; i++) {
          expect(noteToMidi(chord[i])).toBeLessThanOrEqual(
            noteToMidi(chord[i + 1])
          );
        }
      }
    });
  });
});
```

---

## 6. Approval

- [ ] Approved by maintainer
